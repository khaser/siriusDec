<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="static/css/bootstrap.min.css"
          integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

    <title>Сириус</title>

    <style>
        body {
            padding-top: 5rem;
        }
    </style>
</head>
<body>
<main role="main" class="container">
    <div class="starter">
        <h1>Hello world</h1>
    </div>

    <div id="the-log">
    </div>
</main>

<script src="static/js/jquery-3.4.1.slim.min.js"
        integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
        crossorigin="anonymous"></script>
<script src="static/js//popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
<script src="static/js/bootstrap.min.js"
        integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
        crossorigin="anonymous"></script>
<script>
    // Устанавливаем подключение к серверу.
    var ws = new WebSocket("ws://" + document.domain + ":" + location.port + "/ws4");
    messages = document.createElement("ul");
    document.getElementsByClassName("starter")[0].appendChild(messages);

    ws.onmessage = function (event) {

    };

    ws.onopen = function () {
        console.log("Установили соединение с сервером.");
        ws.send("HELP ME");
    };

    function editList(left, right) {
        var inf = 10 ** 9;
        var n = left.length, m = right.length;
        if (n == 0) {
            var fix = [];
            for (let i = 0; i < m; ++i)
                fix.push(["I", i, right[i]]);
            return fix;
        }

        if (m == 0) {
            var fix = [];
            for (let i = 0; i < n; ++i)
                fix.push(["D", i]);
            return fix;
        }


        var dp = [];
        var res = [];
        for (let i = 0; i < n; ++i) {
            var tmp = [];
            var tmp2 = [];
            for (let j = 0; j < m; ++j) {
                tmp.push(inf);
                tmp2.push([-inf, -inf])
            }
            res.push(tmp2);
            dp.push(tmp);
        }
        dp[0][0] = 0;
        for (let i = 0; i < n; ++i) {
            for (let j = 0; j < m; ++j) {
                if (i != 0) {
                    if (dp[i][j] > dp[i - 1][j] + 1) {
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);
                        res[i][j] = [[i - 1, j], ['D', i]];
                    }
                }
                if (j != 0) {
                    if (dp[i][j] > dp[i][j - 1] + 1) {
                        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);
                        res[i][j] = [[i, j - 1], ['I', j, right[j]]];
                    }
                }
                if (j != 0 && i != 0) {
                    if (dp[i][j] > dp[i - 1][j - 1] + 1) {
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1);
                        res[i][j] = [[i - 1, j - 1], ['X', j, right[i]]];
                    }
                    if (left[i] == right[j]) {
                        if (dp[i][j] > dp[i - 1][j - 1]) {
                            res[i][j] = [[i - 1, j - 1], []];
                        }
                        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                    }
                }
            }
        }
        cur = [n - 1, m - 1];
        var ans = [];
        while (cur != -inf) {
            if (typeof(res[cur[0]][cur[1]][1]) == "object" && res[cur[0]][cur[1]][1].length > 1)
                ans.push(res[cur[0]][cur[1]][1]);
            cur = res[cur[0]][cur[1]][0];
        }
        return ans;
    }


    // Документ (строку) будем моделировать как пару множеств:
    //
    //   D1 = { (position, symbol) } -- множество пар позиция+символ
    //   D2 = { position } -- множество удаленных позиций
    //
    // Адресация в документе будет строиться по индексам и по позициям.
    // Индекс -- число -- в классическом понимании идентифицирует символ в строке.
    // Индекс меняется от 0 до длины строки без одного.
    // Позиция -- путь в дереве аллоцированных позиция от корня до листа.
    // Позиция кодируется списком индексов потомков на пути от корня до листа.
    //
    // Пусть A -- арность каждого узла в дереве, например 100.
    //
    //   [0] -- начало строки.
    //   [100] -- конец строки (A).
    //   [0,14] -- идем к "началу строки", далее к 14-му потомку.
    //   [82,11] -- идем к потомку под номером 82, далее к 11-му потомку.
    //
    // === Публичный интерфейс.
    //
    // Создать новый пустой документ.


    function public_newDocument() {
        return {
            D1: new Map([[JSON.stringify([0]), "begin"], [JSON.stringify([100]), "end"]]),
            D2: new Set()
        };
    }

    // Вернуть содержимое документа.
    //
    // Если документ представлен как множество пар (позиция, символ) плюс множество удаленных позиций,
    // то нужно проитерироваться по всем неудаленным позициям в возрастающем порядке и склеить символы.
    function public_getContent(document) {
        var a = [];
        for (let x of document.D1) {
            if (!document.D2.has(x[0])) {
                a.push([JSON.parse(x[0]), x[1]]);
            }
        }
        a.sort(function(a, b) {
            for (let i = 0; i < Math.min(a[0].length, b[0].length); ++i) {
                if (a[0][i] < b[0][i])
                    return -1;
                if (a[0][i] > b[0][i])
                    return 1;
            }
            if (a[0].length < b[0].length)
                return -1;
            else
                return 1;
        });
        var s = "";
        a.forEach(function (x) {
            if (x[1] != "begin" && x[1] != "end")
                s += x[1];
        });
        return s;
    }

    // Функция, которая возвращает сериализованное состояние.(НЕ ДЕБАЖИЛ)
    function public_serializeState(document) {
        var serializedD1 = document.D1;
        var serializedD2 = document.D2;
        document.D1.forEach(function (x) {
            serializedD1.push(x);
        });
        document.D2.forEach(function (x) {
            serializedD2.push(x);
        });
        return JSON.stringify([serializedD1, serializedD2]);
    }

    // Функция, которая обновляет состояние документа с новым сериализованным состоянием.
    function public_mergeStateWith(document, serializedState) {
        var docContent = _getContent(document);
        var stateContent = _getContent(JSON.parse(serializedState));
        var changes = editList(docContent, stateContent);
        for (let i of changes) {
            switch (i) {
                case "X" : public_replace(document, i[1], i[2]); break;
                case "I" : public_insertAfter(document, i[1], i[2]); break;
                case "D" : public_remove(document, i[1]); break;
            }
        }

    }

    // Функция, которая моделирует добавление символа по индексу.
    function public_insertAfter(document, index, symbol) {
        var p = _getPositionByIndex(document, index - 1);
        var q = _getPositionByIndex(document, index);
        var z = _allocate(document, p, q);
        _applyInsert(document, z, symbol);
    }

    // Функция, которая моделирует удаление символа по индексу.
    function public_remove(document, index) {
        var p = _getPositionByIndex(document, index);
        _applyRemove(document, p);
    }

    // Функция, которая моделирует замену символа по индексу.
    function public_replace(document, index, symbol) {
        public_remove(document, index);
        public_insertAfter(document, index - 1, symbol);
    }

    // === Приватный интерфейс.
    //
    // Нам важно уметь преобразовывать индексы в позиции и наоборот.
    //
    // Реализовать функцию, вычисляющую позицию символа по индексу.
    //
    // Если index находится в диапазоне [0; N-1] (N -- длина строки),
    // то возвращаемая позиция кодирует некоторый узел в дереве.
    // Если index равен -1 -- начало строки -- то возвращаемая позиция должна быть [0].
    // Если index равен N -- конец строки -- то возвращаемая позиция должна быть [100].
    function _getPositionByIndex(document, index) {
        var a = [];
        for (let x of document.D1) {
            if (!document.D2.has(x[0])) {
                a.push(JSON.parse(x[0]));
            }
        }
        a.sort(function(a, b) {
            for (let i = 0; i < Math.min(a.length, b.length); ++i) {
                if (a[i] < b[i])
                    return -1;
                if (a[i] > b[i])
                    return 1;
            }
            if (a.length < b.length)
                return -1;
            else
                return 1;
        });
        return a[index + 1];
    }
    const magicK = 15;
    const levelSize = 50;
    // Реализовать функцию, аллоцирующую новую позицию между двумя границами.
    //
    // Стратегии аллокации между двумя вершинами могут быть разные.
    // Важно аллоцировать не слишком "плотно" новые идентификаторы,
    // чтобы обслуживать будущие аллокации без изменения структуры дерева.
    //
    // Пример (здесь "<" значит "предшествует"; K = 10):
    //   begin = [4, 52]
    //   если позиции с [4, 52] до [4, 62] свободны, то
    //   можно аллоцировать [4, 62], так как [4, 52] < [4, 62];
    //   begin = [8, 93]
    //   можно аллоцировать [8, 93, 10], так как [8, 93] < [8, 93, 10];
    //
    // Можно следовать стратегии "аллоцировать ближе к правому краю".
    // Логика схожая, только отталкиваемся от end и шагаем влево.
    // Такая стратегия будет походить для небольших правок в середине текста.
    //
    // Пример (здесь "<" значит "предшествует"; K = 10):
    //   end = [8, 90]
    //   если позиции с [8, 80] до [8, 90] свободны, то
    //   можно аллоцировать [8, 80];
    //   end = [8, 90]
    //   если позиция [8, 89] занята,
    //   то можно аллоцировать [8, 89, 90];
    //
    // Лучше всего -- подбрасывать монетку и выбирать случайно одну из двух стратегий выше.
    // Таким образом мы будем маскировать незнание паттерна правок в документе.
    function _allocate(document, begin, end) {
        if (Math.random() < 0.5) {
            return _allocateLeft(document, begin, end);
        } else {
            return _allocateRight(document, begin, end);
        }
    }


    function _allocateLeft(document, begin, end) {
        var cur = begin.slice();
        cur[cur.length - 1]++;
        while (!document.D1.has(JSON.stringify(cur)) && cur[cur.length - 1] < magicK + begin[begin.length - 1]) {
            cur[cur.length - 1]++;
        }
        if (cur[cur.length - 1] === begin[begin.length - 1] + 1) {
            cur[cur.length - 1] = begin[begin.length - 1];
            cur.push(0);
            return _allocateLeft(document, cur, end);
        } else {
            cur[cur.length - 1]--;
            return cur;
        }
    }

    function _allocateRight(document, begin, end) {
        var cur = end.slice();
        cur[cur.length - 1]--;
        while (!document.D1.has(JSON.stringify(cur)) && cur[cur.length - 1] > 0 && cur[cur.length - 1] + magicK >= end[end.length - 1]) {
            cur[cur.length - 1]--;
        }
        if (cur[cur.length - 1] + 1 === end[end.length - 1]) {
            cur[cur.length - 1] = end[end.length - 1] - 1;
            cur.push(levelSize);
            return _allocateRight(document, begin, cur);
        } else {
            cur[cur.length - 1]++;
            return cur;
        }
    }

    //ACCEPTED Применяем операцию добавления символа symbol в позицию (не индекс!) position.
    function _applyInsert(document, position, symbol) {
        // нужно обновить D1, сохранив нужную пару
        document.D1.set(JSON.stringify(position), symbol);
    }

    //ACCEPTED Применяем операцию удаления символа в позиции position.
    function _applyRemove(document, position) {
        // нужно обновить D2, сохранив удаленную позицию
        document.D2.add(JSON.stringify(position));
    }


</script>
</body>
</html>
